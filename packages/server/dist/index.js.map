{"version":3,"file":"index.js","names":["bodyText: string","json: any","responseData: AccessTokenResponse","accessToken: AccessToken"],"sources":["../src/plainKeyServer.ts"],"sourcesContent":["import {\n  AccessTokenResponse,\n  VerifyAuthenticationTokenResponse,\n  VerifyAuthenticationTokenResult\n} from \"@plainkey/types\"\n\ntype AccessToken = {\n  access_token: string\n\n  // Calculated from expires_in. Will not be exact due to request time.\n  expires_at: Date\n}\n\nexport class PlainKeyServer {\n  private readonly projectId: string\n  private readonly projectSecret: string\n  private readonly baseUrl: string\n  private accessToken?: AccessToken\n\n  constructor(\n    projectId: string,\n    projectSecret: string,\n    baseUrl: string = \"https://api.plainkey.io/server\"\n  ) {\n    if (!projectId) throw new Error(\"Project ID is required\")\n    if (!projectSecret) throw new Error(\"Project secret is required\")\n    if (!baseUrl) throw new Error(\"Base URL is required\")\n\n    this.projectId = projectId\n    this.projectSecret = projectSecret\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\") // Remove trailing slash\n  }\n\n  /**\n   * Helper to parse response JSON.\n   * Throws error if status code is not 200 OK, if the response is not valid JSON.\n   */\n  private async parseResponse<T = any>(\n    response: Response,\n    acceptedErrorCodes?: number[]\n  ): Promise<T> {\n    let bodyText: string\n\n    // Read as text first to avoid JSON.parse errors on any HTML/plaintext error responses.\n    try {\n      bodyText = await response.text()\n    } catch {\n      throw new Error(\"Network error while reading server response\")\n    }\n\n    // Parse the response text as JSON.\n    let json: any\n\n    try {\n      json = bodyText ? JSON.parse(bodyText) : {}\n    } catch {\n      if (!response.ok) throw new Error(\"Server returned an invalid JSON error response\")\n      throw new Error(\"Invalid JSON received from server\")\n    }\n\n    if (!response.ok) {\n      // If status code is a acceped error code we parse return the parsed JSON instead of the error.\n      if (acceptedErrorCodes && acceptedErrorCodes.includes(response.status)) {\n        return json as T\n      }\n\n      // Server should return { error: string }\n      const message = json && typeof json.error === \"string\" ? json.error : \"Unknown server error\"\n      throw new Error(message)\n    }\n\n    return json as T\n  }\n\n  /**\n   * Fetches a new access token from the server and sets it in the instance variable.\n   * @returns The access token object that was set in or retreived from the instance variable.\n   */\n  private async ensureAccessToken(): Promise<AccessToken> {\n    // We only fetch a new access token if none is set or it is close to expiration/have been expired.\n    // Expiration should be 60 minutes. Grace period: 10 minutes.\n    const gracePeriodDate = new Date(Date.now() + 10 * 60 * 1000)\n\n    if (this.accessToken && this.accessToken.expires_at > gracePeriodDate) {\n      return this.accessToken\n    }\n\n    // Fetch the access token from the PlainKey Server API.\n    const response = await fetch(`${this.baseUrl}/access-token`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n      body: new URLSearchParams({\n        client_id: this.projectId,\n        client_secret: this.projectSecret\n      })\n    })\n\n    // Parse the response data\n    const responseData: AccessTokenResponse =\n      await this.parseResponse<AccessTokenResponse>(response)\n\n    // Make into the internal access token object.\n    const accessToken: AccessToken = {\n      access_token: responseData.access_token,\n      expires_at: new Date(Date.now() + responseData.expires_in * 1000)\n    }\n\n    // Set the access token in the instance variable\n    this.accessToken = accessToken\n    return accessToken\n  }\n\n  /**\n   * Returns the default headers to use for all server API requests using the access token.\n   * Includes the content type and the access token.\n   * It makes sure to fetch a new access token if one is not already set.\n   * @returns The default headers to use for all requests.\n   */\n  private async defaultRequestHeaders(): Promise<Headers> {\n    const accessToken: AccessToken = await this.ensureAccessToken()\n\n    return new Headers({\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken.access_token}`,\n      \"x-project-id\": this.projectId\n    })\n  }\n\n  /**\n   * Verifies a user authentication token.\n   * If the token is valid, it returns the authenticated user's PlainKey User ID.\n   *\n   * @param authenticationToken - The authentication token to verify.\n   * @returns On success, an object containing the authenticated user's PlainKey User ID.\n   * On failure, throws an error.\n   */\n  async verifyAuthenticationToken(\n    authenticationToken: string\n  ): Promise<VerifyAuthenticationTokenResult> {\n    // Verify the authentication token with the PlainKey Server API.\n    const response = await fetch(`${this.baseUrl}/authentication-token/verify`, {\n      method: \"POST\",\n      headers: await this.defaultRequestHeaders(),\n      body: JSON.stringify({ token: authenticationToken })\n    })\n\n    // Parse the response data\n    const acceptedErrorCodes = [401]\n    const responseData = await this.parseResponse<VerifyAuthenticationTokenResponse>(\n      response,\n      acceptedErrorCodes\n    )\n\n    // Throw error on invalid authentication token\n    if (!responseData.valid) {\n      throw new Error(responseData.error ?? \"Invalid authentication token.\")\n    }\n\n    // Authentication token is valid\n    return { userId: responseData.userId }\n  }\n\n  // TODO: Begin passkey registration\n}\n"],"mappings":";AAaA,IAAa,iBAAb,MAA4B;CAM1B,YACE,WACA,eACA,UAAkB,kCAClB;AACA,MAAI,CAAC,UAAW,OAAM,IAAI,MAAM,yBAAyB;AACzD,MAAI,CAAC,cAAe,OAAM,IAAI,MAAM,6BAA6B;AACjE,MAAI,CAAC,QAAS,OAAM,IAAI,MAAM,uBAAuB;AAErD,OAAK,YAAY;AACjB,OAAK,gBAAgB;AACrB,OAAK,UAAU,QAAQ,QAAQ,OAAO,GAAG;;;;;;CAO3C,MAAc,cACZ,UACA,oBACY;EACZ,IAAIA;AAGJ,MAAI;AACF,cAAW,MAAM,SAAS,MAAM;UAC1B;AACN,SAAM,IAAI,MAAM,8CAA8C;;EAIhE,IAAIC;AAEJ,MAAI;AACF,UAAO,WAAW,KAAK,MAAM,SAAS,GAAG,EAAE;UACrC;AACN,OAAI,CAAC,SAAS,GAAI,OAAM,IAAI,MAAM,iDAAiD;AACnF,SAAM,IAAI,MAAM,oCAAoC;;AAGtD,MAAI,CAAC,SAAS,IAAI;AAEhB,OAAI,sBAAsB,mBAAmB,SAAS,SAAS,OAAO,CACpE,QAAO;GAIT,MAAM,UAAU,QAAQ,OAAO,KAAK,UAAU,WAAW,KAAK,QAAQ;AACtE,SAAM,IAAI,MAAM,QAAQ;;AAG1B,SAAO;;;;;;CAOT,MAAc,oBAA0C;EAGtD,MAAM,kBAAkB,IAAI,KAAK,KAAK,KAAK,GAAG,MAAU,IAAK;AAE7D,MAAI,KAAK,eAAe,KAAK,YAAY,aAAa,gBACpD,QAAO,KAAK;EAId,MAAM,WAAW,MAAM,MAAM,GAAG,KAAK,QAAQ,gBAAgB;GAC3D,QAAQ;GACR,SAAS,EAAE,gBAAgB,qCAAqC;GAChE,MAAM,IAAI,gBAAgB;IACxB,WAAW,KAAK;IAChB,eAAe,KAAK;IACrB,CAAC;GACH,CAAC;EAGF,MAAMC,eACJ,MAAM,KAAK,cAAmC,SAAS;EAGzD,MAAMC,cAA2B;GAC/B,cAAc,aAAa;GAC3B,YAAY,IAAI,KAAK,KAAK,KAAK,GAAG,aAAa,aAAa,IAAK;GAClE;AAGD,OAAK,cAAc;AACnB,SAAO;;;;;;;;CAST,MAAc,wBAA0C;EACtD,MAAMA,cAA2B,MAAM,KAAK,mBAAmB;AAE/D,SAAO,IAAI,QAAQ;GACjB,gBAAgB;GAChB,eAAe,UAAU,YAAY;GACrC,gBAAgB,KAAK;GACtB,CAAC;;;;;;;;;;CAWJ,MAAM,0BACJ,qBAC0C;EAE1C,MAAM,WAAW,MAAM,MAAM,GAAG,KAAK,QAAQ,+BAA+B;GAC1E,QAAQ;GACR,SAAS,MAAM,KAAK,uBAAuB;GAC3C,MAAM,KAAK,UAAU,EAAE,OAAO,qBAAqB,CAAC;GACrD,CAAC;EAIF,MAAM,eAAe,MAAM,KAAK,cAC9B,UAFyB,CAAC,IAAI,CAI/B;AAGD,MAAI,CAAC,aAAa,MAChB,OAAM,IAAI,MAAM,aAAa,SAAS,gCAAgC;AAIxE,SAAO,EAAE,QAAQ,aAAa,QAAQ"}