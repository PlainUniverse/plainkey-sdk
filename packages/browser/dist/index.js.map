{"version":3,"file":"index.js","names":["bodyText: string","json: any","beginRequestBody: UserRegisterBeginRequest","completeRequestBody: UserRegisterCompleteRequest","completeResponseData: UserRegisterCompleteResponse","beginParams: UserCredentialBeginRequest","completeParams: UserCredentialCompleteRequest","completeResponseData: UserCredentialCompleteResponse","updateLabelParams: CredentialLabelUpdateRequest","beginParams: LoginBeginRequest","beginResponseData: AuthenticationBeginResponse","authenticationResponse: AuthenticationResponseJSON","completeParams: LoginCompleteRequest"],"sources":["../src/plainKey.ts"],"sourcesContent":["import { startAuthentication, startRegistration } from \"@simplewebauthn/browser\"\nimport { RegistrationResponseJSON, AuthenticationResponseJSON } from \"@simplewebauthn/browser\"\n\nimport type {\n  UserCredentialBeginRequest,\n  UserCredentialCompleteRequest,\n  LoginBeginRequest,\n  LoginCompleteRequest,\n  UserIdentifier,\n  CreateUserWithPasskeyResult,\n  AddPasskeyResult,\n  AuthenticateResult,\n  UserRegisterBeginRequest,\n  UserRegisterBeginResponse,\n  UserRegisterCompleteRequest,\n  UserRegisterCompleteResponse,\n  AuthenticationCompleteResponse,\n  AuthenticationBeginResponse,\n  CredentialLabelUpdateRequest,\n  UpdatePasskeyLabelResult\n} from \"@plainkey/types\"\n\nimport type { UserCredentialBeginResponse, UserCredentialCompleteResponse } from \"@plainkey/types\"\n\n/**\n * PlainKey client for the browser. Used to register new users, add passkeys to existing users, and log users in.\n *\n * Docs: https://plainkey.io/docs\n *\n * @param projectId - Your PlainKey project ID. You can find it in the PlainKey admin dashboard.\n * @param baseUrl - Set by default to https://api.plainkey.io/browser. Change only for development purposes.\n */\nexport class PlainKey {\n  private readonly projectId: string\n  private readonly baseUrl: string\n\n  constructor(projectId: string, baseUrl: string = \"https://api.plainkey.io/browser\") {\n    if (!projectId) throw new Error(\"Project ID is required\")\n    if (!baseUrl) throw new Error(\"Base URL is required\")\n\n    this.projectId = projectId\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\") // Remove trailing slash\n  }\n\n  /**\n   * Helper to parse response JSON.\n   * Throws error if status code is not 200 OK, if the response is not valid JSON.\n   */\n  private async parseResponse<T = any>(response: Response): Promise<T> {\n    let bodyText: string\n\n    // Read as text first to avoid JSON.parse errors on any HTML/plaintext error responses.\n    try {\n      bodyText = await response.text()\n    } catch {\n      throw new Error(\"Network error while reading server response\")\n    }\n\n    // Parse the response text as JSON.\n    let json: any\n\n    try {\n      json = bodyText ? JSON.parse(bodyText) : {}\n    } catch {\n      if (!response.ok) throw new Error(\"Server returned an invalid JSON error response\")\n      throw new Error(\"Invalid JSON received from server\")\n    }\n\n    if (!response.ok) {\n      // Server should return { error: string }\n      const message = json && typeof json.error === \"string\" ? json.error : \"Unknown server error\"\n      throw new Error(message)\n    }\n\n    return json as T\n  }\n\n  /**\n   * Registration of a new user with a passkey. Will require user interaction to create a passkey.\n   *\n   * @param userName - A unique identifier for the user, like an email address or username.\n   * Can be empty for usernameless authentication.\n   */\n  async createUserWithPasskey(userName?: string): Promise<CreateUserWithPasskeyResult> {\n    try {\n      // Step 1: Get registration options from server\n      const beginRequestBody: UserRegisterBeginRequest = { userName }\n      const beginResponse = await fetch(`${this.baseUrl}/user/register/begin`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(beginRequestBody)\n      })\n\n      // Parse response JSON\n      const { userId, options } = await this.parseResponse<UserRegisterBeginResponse>(beginResponse)\n\n      // Step 2: Create credential using browser's WebAuthn API\n      const credential: RegistrationResponseJSON = await startRegistration({\n        optionsJSON: options\n      })\n\n      // Step 3: Send credential to server for verification\n      const completeRequestBody: UserRegisterCompleteRequest = { userId, credential }\n      const completeResponse = await fetch(`${this.baseUrl}/user/register/complete`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(completeRequestBody)\n      })\n\n      // Parse response JSON\n      const completeResponseData: UserRegisterCompleteResponse =\n        await this.parseResponse<UserRegisterCompleteResponse>(completeResponse)\n\n      if (!completeResponseData.success) throw new Error(\"Server could not complete registration\")\n\n      // Return success\n      return {\n        success: completeResponseData.success,\n        data: {\n          userId: completeResponseData.userId,\n          authenticationToken: completeResponseData.authenticationToken,\n          credential: completeResponseData.credential\n        }\n      }\n    } catch (error) {\n      // Return error\n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : \"Unknown error\"\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds a passkey to an existing user. Will require user interaction to create a passkey.\n   *\n   * @param authenticationToken - The user authentication token, is returned from .authenticate() and createUserWithPasskey().\n   * Do NOT store it in local storage, database, etc. Always keep it in memory.\n   * @param userName - A unique identifier for the user, like an email address or username.\n   * If not provided, the user's stored userName will be used.\n   */\n  async addPasskey(authenticationToken: string, userName?: string): Promise<AddPasskeyResult> {\n    if (!authenticationToken) throw new Error(\"Authentication token is required\")\n\n    try {\n      // Step 1: Get credential registration options from server\n      const beginParams: UserCredentialBeginRequest = { authenticationToken, userName }\n      const beginResponse = await fetch(`${this.baseUrl}/user/credential/begin`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(beginParams)\n      })\n\n      // Parse response JSON\n      const { options }: UserCredentialBeginResponse =\n        await this.parseResponse<UserCredentialBeginResponse>(beginResponse)\n\n      // Step 2: Create credential using browser's WebAuthn API\n      const credential: RegistrationResponseJSON = await startRegistration({ optionsJSON: options })\n\n      // Step 3: Send credential to server for verification\n      const completeParams: UserCredentialCompleteRequest = { authenticationToken, credential }\n\n      const completeResponse = await fetch(`${this.baseUrl}/user/credential/complete`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(completeParams)\n      })\n\n      // Parse response JSON\n      const completeResponseData: UserCredentialCompleteResponse =\n        await this.parseResponse<UserCredentialCompleteResponse>(completeResponse)\n\n      if (!completeResponseData.success)\n        throw new Error(\"Server could not complete passkey registration\")\n\n      // Return success\n      return {\n        success: completeResponseData.success,\n        data: {\n          authenticationToken: completeResponseData.authenticationToken,\n          credential: completeResponseData.credential\n        }\n      }\n    } catch (error) {\n      // Return error\n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : \"Unknown error\"\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates a passkey label. Requires authentication shortly before this call. Any passkey registered to the user can be updated.\n   * @param authenticationToken - The user authentication token, is returned from .authenticate() and createUserWithPasskey().\n   * Do NOT store it in local storage, database, etc. Always keep it in memory.\n   * @param credentialId - The ID of the passkey credential to update. Is returned from createUserWithPasskey() and addPasskey().\n   * @param label - The new label for the passkey.\n   */\n  async updatePasskeyLabel(\n    authenticationToken: string,\n    credentialId: string,\n    label: string\n  ): Promise<UpdatePasskeyLabelResult> {\n    if (!authenticationToken) throw new Error(\"Authentication token is required\")\n    if (!credentialId) throw new Error(\"Credential ID is required\")\n    // Empty label is allowed\n\n    try {\n      const updateLabelParams: CredentialLabelUpdateRequest = { authenticationToken, label }\n      const updateLabelResponse = await fetch(`${this.baseUrl}/credential/${credentialId}/label`, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(updateLabelParams)\n      })\n\n      if (!updateLabelResponse.ok) throw new Error(\"Failed to update passkey label\")\n\n      // Return success\n      return { success: true }\n    } catch (error) {\n      // Return error\n      return {\n        success: false,\n        error: { message: error instanceof Error ? error.message : \"Unknown error\" }\n      }\n    }\n  }\n\n  /**\n   * Authenticates a user. Can be used for login, verification, 2FA, etc.\n   * Will require user interaction to authenticate.\n   *\n   * @param userIdentifier - Optional object containing either the user's PlainKey User ID or their userName.\n   * Does not have to be provided for usernameless authentication.\n   */\n  async authenticate(userIdentifier?: UserIdentifier): Promise<AuthenticateResult> {\n    try {\n      // Step 1: Get authentication options from server\n      const beginParams: LoginBeginRequest = { userIdentifier }\n      const beginResponse = await fetch(`${this.baseUrl}/authenticate/begin`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(beginParams)\n      })\n\n      // Parse response JSON\n      const beginResponseData: AuthenticationBeginResponse =\n        await this.parseResponse<AuthenticationBeginResponse>(beginResponse)\n\n      if (!beginResponseData.options)\n        throw new Error(\"Server returned no options in login begin response\")\n\n      // Step 2: Pass options to the authenticator and wait for response\n      const authenticationResponse: AuthenticationResponseJSON = await startAuthentication({\n        optionsJSON: beginResponseData.options\n      })\n\n      if (!authenticationResponse) throw new Error(\"No authentication response from browser\")\n\n      // Step 3: POST the response to the server\n      // This uses the authentication session ID from the begin response - always in JS memory.\n      // Do not store it in local storage, database, etc.\n      const completeParams: LoginCompleteRequest = {\n        loginSessionId: beginResponseData.loginSession.id,\n        authenticationResponse\n      }\n\n      const authenticateCompleteResponse = await fetch(`${this.baseUrl}/authenticate/complete`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-project-id\": this.projectId\n        },\n        body: JSON.stringify(completeParams)\n      })\n\n      const authCompleteResponseData: AuthenticationCompleteResponse =\n        await this.parseResponse<AuthenticationCompleteResponse>(authenticateCompleteResponse)\n\n      // Return success\n      return {\n        success: true,\n        data: {\n          authenticationToken: authCompleteResponseData.authenticationToken\n        }\n      }\n    } catch (error) {\n      // Return error\n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : \"Unknown error\"\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"}